# Chess Broadcasting App - Complete Implementation Guide

> **Purpose**: This document provides a comprehensive guide for implementing a chess broadcasting application that fetches live ongoing tournaments from Lichess and streams live game positions with real-time evaluations.

---

## Table of Contents
1. [System Overview](#system-overview)
2. [Architecture](#architecture)
3. [Core Features](#core-features)
4. [Technology Stack](#technology-stack)
5. [Data Flow](#data-flow)
6. [API Integration](#api-integration)
7. [Component Breakdown](#component-breakdown)
8. [Implementation Steps](#implementation-steps)
9. [Code Examples](#code-examples)
10. [Deployment](#deployment)

---

## System Overview

The Chess Broadcasting App is a React-based application designed to display real-time chess game evaluations for multiple games happening simultaneously in live tournaments. It uses the Lichess API to fetch live tournaments and streams game data in real-time.

### Key Capabilities
- **Live Tournament Discovery**: Fetches ongoing chess tournaments from Lichess
- **Real-time Game Streaming**: Streams live game positions using Server-Sent Events (SSE) via PGN format
- **Position Evaluation**: Evaluates chess positions using Stockfish engine
- **Multiple Game Display**: Shows evaluation bars for multiple games simultaneously
- **Blunder Detection**: Detects and alerts when significant evaluation changes occur
- **Customizable UI**: Allows customization of colors, layouts, and styling

---

## Architecture

```mermaid
graph TB
    A[React Frontend] --> B[Tournament Selection UI]
    A --> C[Live Game Display]
    A --> D[Evaluation Bars]
    
    B --> E[Lichess Broadcast API]
    E --> F[GET /api/broadcast]
    
    C --> G[Lichess Stream API]
    G --> H[GET /api/stream/broadcast/round/:id.pgn]
    
    D --> I[Stockfish Backend]
    I --> J[Flask API Server]
    J --> K[Stockfish Engine]
    
    H --> L[PGN Stream Parser]
    L --> M[Chess.js - PGN to FEN]
    M --> I
    I --> D
    
    style A fill:#4CAF50
    style E fill:#FFB74D
    style G fill:#FFB74D
    style I fill:#64B5F6
```

### Component Architecture

```
src/
├── app/
│   └── evalbars/
│       ├── App.js              # Main application logic
│       └── App.css             # Main styling
├── components/
│   ├── tournaments-list/
│   │   └── TournamentsList.js  # Tournament selection UI
│   ├── evalbar/
│   │   ├── EvalBar.js          # Individual evaluation bar component
│   │   └── EvalBar.css         # Evaluation bar styling
│   └── customize-evalbar/
│       └── CustomizeEvalBar.js # Customization controls
└── assets/
    └── blunder-sound.mp3       # Blunder alert sound
```

---

## Core Features

### 1. Fetching Live Ongoing Tournaments

The app queries the Lichess Broadcast API to retrieve currently ongoing chess tournaments.

**API Endpoint**: `https://lichess.org/api/broadcast?nb=50`

**Response Format**: NDJSON (Newline Delimited JSON)

Each line represents a broadcast/tournament with this structure:
```json
{
  "tour": {
    "id": "tournament-id",
    "name": "Tournament Name",
    "description": "Tournament description",
    "url": "https://lichess.org/broadcast/...",
    "date": "YYYY-MM-DD"
  },
  "rounds": [
    {
      "id": "round-id",
      "name": "Round Name",
      "ongoing": true
    }
  ],
  "image": "https://image-url.jpg"
}
```

**Filtering Logic**:
- Only tournaments with `rounds` array are considered
- Only rounds where `ongoing === true` are displayed
- If no ongoing tournaments exist, a "No broadcasts" message is shown

### 2. Live Position Streaming

Once a tournament is selected, the app streams live game data using Server-Sent Events (SSE).

**Stream Endpoint**: `https://lichess.org/api/stream/broadcast/round/{roundId}.pgn`

**Stream Format**: Continuous PGN (Portable Game Notation) stream

The stream continuously updates with game moves in PGN format:
```
[Event "Tournament Name"]
[Site "Location"]
[Date "2025.12.26"]
[Round "1"]
[White "Player, White"]
[Black "Player, Black"]
[Result "*"]

1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 *
```

**Stream Processing**:
1. Uses Fetch API with streaming response
2. Reads chunks using `ReadableStream.getReader()`
3. Accumulates PGN data in a buffer
4. Splits games by triple newline `\n\n\n`
5. Parses PGN headers to extract player names
6. Converts moves to FEN using Chess.js library

### 3. Real-time Position Evaluation

Positions are evaluated using a Stockfish backend server.

**Evaluation Endpoint**: `https://stockfish.broadcastsofcbi.live/evaluate?fen={fen}`

**Request**: GET with FEN string as query parameter
**Response**:
```json
{
  "evaluation": 0.5
}
```

**Evaluation Scoring**:
- Positive values: White is better
- Negative values: Black is better
- Range: -5 to +5 for normal positions
- ±9999: Indicates forced checkmate

---

## Technology Stack

### Frontend
- **React** (^18.2.0): UI framework
- **Chess.js** (^1.0.0-beta.6): Chess logic and PGN parsing
- **Material-UI** (@mui/material ^5.14.19): UI components
- **Styled Components** (^6.1.1): CSS-in-JS styling
- **React Router** (^6.20.0): Navigation

### Backend
- **Flask**: Python web server
- **Flask-CORS**: Cross-origin resource sharing
- **Stockfish**: Chess engine for position evaluation
- **python-chess**: Chess library for Python

### External APIs
- **Lichess Broadcast API**: Tournament data
- **Lichess Stream API**: Live game streaming

---

## Data Flow

### 1. Tournament Selection Flow

```mermaid
sequenceDiagram
    participant User
    participant TournamentsList
    participant Lichess API
    participant App
    
    User->>TournamentsList: Opens app
    TournamentsList->>Lichess API: GET /api/broadcast?nb=50
    Lichess API-->>TournamentsList: NDJSON stream
    TournamentsList->>TournamentsList: Filter ongoing rounds
    TournamentsList->>User: Display tournaments
    User->>TournamentsList: Select tournament(s)
    TournamentsList->>App: onSelect(tournamentIds)
    App->>App: startStreaming(tournamentId)
```

### 2. Live Game Streaming Flow

```mermaid
sequenceDiagram
    participant App
    participant Lichess Stream
    participant PGN Parser
    participant Chess.js
    participant Stockfish
    participant EvalBar
    
    App->>Lichess Stream: Start streaming roundId
    loop Every ~10ms
        Lichess Stream-->>App: PGN chunk
        App->>PGN Parser: Accumulate PGN data
        PGN Parser->>App: Extract game PGNs
        App->>Chess.js: Load PGN
        Chess.js-->>App: Current FEN position
        App->>Stockfish: Evaluate FEN
        Stockfish-->>App: Evaluation score
        App->>EvalBar: Update evaluation
        EvalBar->>User: Display bar
    end
```

### 3. Evaluation Update Cycle

```javascript
// Continuous update loop
setInterval(() => {
  updateEvaluations(); // Updates all active games
}, 2000); // Every 2 seconds
```

---

## API Integration

### 1. Lichess Broadcast API

**Purpose**: Fetch list of ongoing tournaments

**Endpoint**: `https://lichess.org/api/broadcast?nb=50`

**Method**: GET

**Parameters**:
- `nb`: Number of broadcasts to retrieve (default: 50)

**Response Type**: NDJSON (Newline Delimited JSON)

**Implementation**:
```javascript
fetch("https://lichess.org/api/broadcast?nb=50")
  .then(response => response.text())
  .then(data => {
    const jsonData = data
      .trim()
      .split("\n")
      .map(line => JSON.parse(line));
    
    const ongoingTournaments = jsonData.filter(tournament =>
      tournament.rounds && 
      tournament.rounds.some(round => round.ongoing === true)
    );
    
    setTournaments(ongoingTournaments);
  });
```

### 2. Lichess Stream API

**Purpose**: Stream live game positions in PGN format

**Endpoint**: `https://lichess.org/api/stream/broadcast/round/{roundId}.pgn`

**Method**: GET (with streaming)

**Response Type**: Continuous PGN stream

**Implementation**:
```javascript
const startStreaming = async (tournamentId) => {
  const abortController = new AbortController();
  const streamURL = `https://lichess.org/api/stream/broadcast/round/${tournamentId}.pgn`;
  
  const response = await fetch(streamURL, {
    signal: abortController.signal
  });
  
  const reader = response.body.getReader();
  let buffer = "";
  
  const processStream = async () => {
    const { done, value } = await reader.read();
    if (done) return;
    
    buffer += new TextDecoder().decode(value);
    
    // Process accumulated PGN data
    parseGames(buffer);
    
    // Continue reading
    setTimeout(processStream, 10);
  };
  
  processStream();
};
```

### 3. Stockfish Evaluation API

**Purpose**: Evaluate chess positions

**Endpoint**: `https://stockfish.broadcastsofcbi.live/evaluate?fen={fen}`

**Method**: GET

**Parameters**:
- `fen`: FEN string of the position (URL-encoded)

**Response**:
```json
{
  "evaluation": 1.2
}
```

**Backend Implementation** (Flask + Stockfish):
```python
from flask import Flask, request, jsonify
from stockfish import Stockfish

app = Flask(__name__)
stockfish = Stockfish(stockfish_path)
stockfish.set_depth(10)

@app.route('/evaluate', methods=['GET'])
def evaluate():
    fen = request.args.get('fen')
    
    if not fen:
        return jsonify(error="FEN string not provided"), 400
    
    stockfish.set_fen_position(fen)
    evaluation = stockfish.get_evaluation()
    
    if evaluation["type"] == "cp":
        score = evaluation["value"] / 100.0
    elif evaluation["type"] == "mate":
        score = 9999 * evaluation["value"] / abs(evaluation["value"])
    
    score = score * 1.2  # Amplification factor
    score = round(score, 1)
    
    return jsonify(evaluation=score)
```

---

## Component Breakdown

### 1. TournamentsList Component

**File**: [src/components/tournaments-list/TournamentsList.js](file:///c:/Users/2025/Desktop/Code/eval-bar/src/components/tournaments-list/TournamentsList.js)

**Purpose**: Display and allow selection of live tournaments

**Key Features**:
- Fetches tournaments on mount
- Filters for ongoing rounds only
- Search functionality
- Custom URL input for specific broadcasts
- Checkbox selection for multiple tournaments
- Confirmation before loading

**State Management**:
```javascript
const [tournaments, setTournaments] = useState([]);
const [filteredTournaments, setFilteredTournaments] = useState([]);
const [searchTerm, setSearchTerm] = useState("");
const [selectedTournaments, setSelectedTournaments] = useState([]);
const [checkedItems, setCheckedItems] = useState({});
const [customUrl, setCustomUrl] = useState("");
```

**Key Functions**:
```javascript
// Fetch tournaments
useEffect(() => {
  fetch("https://lichess.org/api/broadcast?nb=50")
    .then(response => response.text())
    .then(data => {
      const jsonData = data.trim().split("\n").map(line => JSON.parse(line));
      const ongoingTournaments = jsonData.filter(tournament =>
        tournament.rounds && 
        tournament.rounds.some(round => round.ongoing === true)
      );
      setTournaments(ongoingTournaments);
    });
}, []);

// Handle selection
const handleCheckboxChange = (tournamentId) => {
  setCheckedItems(prev => ({
    ...prev,
    [tournamentId]: !prev[tournamentId]
  }));
  
  // Add/remove from selected tournaments
  setSelectedTournaments(prev =>
    prev.includes(tournamentId)
      ? prev.filter(id => id !== tournamentId)
      : [...prev, tournamentId]
  );
};
```

### 2. App Component (Main Evalbars App)

**File**: [src/app/evalbars/App.js](file:///c:/Users/2025/Desktop/Code/eval-bar/src/app/evalbars/App.js)

**Purpose**: Main application logic, manages game streaming and evaluation updates

**Key State**:
```javascript
const [broadcastIDs, setBroadcastIDs] = useState([]);
const [isBroadcastLoaded, setIsBroadcastLoaded] = useState(false);
const [links, setLinks] = useState([]); // Active games with evaluations
const [availableGames, setAvailableGames] = useState([]);
const [selectedGames, setSelectedGames] = useState([]);
const [customStyles, setCustomStyles] = useState({...});
const allGames = useRef(""); // Accumulated PGN data
```

**Critical Functions**:

#### a) Start Streaming
```javascript
const startStreaming = async (tournamentId) => {
  const abortController = new AbortController();
  abortControllers.current[tournamentId] = abortController;
  
  const streamURL = `https://lichess.org/api/stream/broadcast/round/${tournamentId}.pgn`;
  const response = await fetch(streamURL, {
    signal: abortController.signal
  });
  
  const reader = response.body.getReader();
  
  const processStream = async () => {
    const { done, value } = await reader.read();
    if (done) return;
    
    allGames.current += new TextDecoder().decode(value);
    updateEvaluations();
    fetchAvailableGames();
    
    setTimeout(processStream, 10); // Continue every 10ms
  };
  
  processStream();
};
```

#### b) Parse Available Games
```javascript
const fetchAvailableGames = () => {
  const games = allGames.current.split("\n\n\n");
  const gameOptions = games
    .map(game => {
      const whiteMatch = game.match(/\[White "(.*?)"\]/);
      const blackMatch = game.match(/\[Black "(.*?)"\]/);
      return whiteMatch && blackMatch
        ? `${whiteMatch[1]} - ${blackMatch[1]}`
        : null;
    })
    .filter(Boolean);
  
  setAvailableGames(Array.from(new Set(gameOptions)));
};
```

#### c) Update Evaluations
```javascript
const updateEvaluationsForLink = async (link) => {
  const games = allGames.current.split("\n\n\n");
  
  // Find the specific game PGN
  const specificGamePgn = games.reverse().find(game => {
    const whiteNameMatch = game.match(/\[White "(.*?)"\]/);
    const blackNameMatch = game.match(/\[Black "(.*?)"\]/);
    return whiteNameMatch && blackNameMatch &&
      `${whiteNameMatch[1]} - ${blackNameMatch[1]}` === 
      `${link.whitePlayer} - ${link.blackPlayer}`;
  });
  
  if (specificGamePgn) {
    // Clean PGN (remove headers and comments)
    const cleanedPgn = specificGamePgn
      .split("\n")
      .filter(line => !line.startsWith("["))
      .join(" ")
      .replace(/ {.*?}/g, "")
      .trim();
    
    // Parse with Chess.js
    const chess = new Chess();
    chess.loadPgn(cleanedPgn);
    const currentFEN = chess.fen();
    
    // Only update if position changed
    if (currentFEN !== link.lastFEN) {
      const evalData = await fetchEvaluation(currentFEN);
      
      setLinks(prevLinks => {
        const updatedLinks = [...prevLinks];
        const idx = updatedLinks.findIndex(l =>
          l.whitePlayer === link.whitePlayer &&
          l.blackPlayer === link.blackPlayer
        );
        
        if (idx !== -1) {
          updatedLinks[idx] = {
            ...link,
            evaluation: evalData.evaluation,
            lastFEN: currentFEN
          };
        }
        
        return updatedLinks;
      });
    }
  }
};
```

#### d) Continuous Update Loop
```javascript
useEffect(() => {
  if (links.length) {
    const interval = setInterval(() => {
      updateEvaluations();
    }, 2000); // Update every 2 seconds
    
    return () => clearInterval(interval);
  }
}, [links]);
```

### 3. EvalBar Component

**File**: [src/components/evalbar/EvalBar.js](file:///c:/Users/2025/Desktop/Code/eval-bar/src/components/evalbar/EvalBar.js)

**Purpose**: Display individual game evaluation bar

**Props**:
- `evaluation`: Current position evaluation (-5 to +5)
- `whitePlayer`: White player name
- `blackPlayer`: Black player name
- `result`: Game result ("1-0", "0-1", "Draw", or null)
- `customStyles`: Custom color scheme
- `alert`: Blunder alert flag
- [onBlunder](file:///c:/Users/2025/Desktop/Code/eval-bar/src/components/evalbar/EvalBar.js#24-31): Blunder callback function

**Key Features**:
- Visual evaluation bar (white/black)
- Player names with formatting
- Blunder detection
- Result display
- Move number display

**Blunder Detection**:
```javascript
useEffect(() => {
  if (prevEvaluationRef.current !== null) {
    const prevEval = prevEvaluationRef.current;
    const currentEval = evaluation;
    
    const isBlunder = (prevEval, currentEval) => {
      if (prevEval >= -4 && prevEval <= 4) {
        if (Math.abs(currentEval - prevEval) >= 0.6) {
          return true;
        }
      }
      return false;
    };
    
    if (isBlunder(prevEval, currentEval)) {
      onBlunder();
      playBlunderSound();
    }
  }
  
  prevEvaluationRef.current = evaluation;
}, [evaluation]);
```

**Bar Width Calculation**:
```javascript
const getWhiteBarWidth = () => {
  if (evaluation >= 99) return "100%";     // Checkmate for White
  if (evaluation >= 4) return "90%";       // Winning for White
  if (evaluation <= -4) return "10%";      // Winning for Black
  
  // Linear interpolation for normal positions
  return `${50 + (evaluation * 7.5)}%`;
};
```

---

## Implementation Steps

### Step 1: Project Setup

```bash
# Create React app
npx create-react-app chess-broadcast-app
cd chess-broadcast-app

# Install dependencies
npm install chess.js@1.0.0-beta.6
npm install @mui/material @emotion/react @emotion/styled
npm install styled-components
npm install react-router-dom
npm install axios
```

### Step 2: Backend Setup (Stockfish Server)

```bash
# Create Python environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install flask flask-cors stockfish

# Download Stockfish binary
# Place in stockfish_binaries/ directory
```

**Create [chess_api.py](file:///c:/Users/2025/Desktop/Code/eval-bar/chess_api.py)**:
```python
from flask import Flask, request, jsonify
from flask_cors import CORS
from stockfish import Stockfish
import os

app = Flask(__name__)
CORS(app)

stockfish_path = "stockfish_binaries/stockfish-windows-x86-64-avx2.exe"
stockfish = Stockfish(stockfish_path)
stockfish.set_depth(10)

@app.route('/evaluate', methods=['GET'])
def evaluate():
    fen = request.args.get('fen')
    
    if not fen:
        return jsonify(error="FEN string not provided"), 400
    
    stockfish.set_fen_position(fen)
    evaluation = stockfish.get_evaluation()
    
    if evaluation["type"] == "cp":
        score = evaluation["value"] / 100.0
    elif evaluation["type"] == "mate":
        score = 9999 * evaluation["value"] / abs(evaluation["value"])
    
    score = score * 1.2
    score = round(score, 1)
    
    return jsonify(evaluation=score)

if __name__ == '__main__':
    app.run(debug=True, port=5000)
```

### Step 3: Create TournamentsList Component

```bash
mkdir -p src/components/tournaments-list
```

**Create [src/components/tournaments-list/TournamentsList.js](file:///c:/Users/2025/Desktop/Code/eval-bar/src/components/tournaments-list/TournamentsList.js)**:

```javascript
import React, { useState, useEffect } from "react";
import styled from "styled-components";

const TournamentsList = ({ onSelect }) => {
  const [tournaments, setTournaments] = useState([]);
  const [selectedTournaments, setSelectedTournaments] = useState([]);

  useEffect(() => {
    fetch("https://lichess.org/api/broadcast?nb=50")
      .then(response => response.text())
      .then(data => {
        const jsonData = data.trim().split("\n").map(line => JSON.parse(line));
        const ongoingTournaments = jsonData.filter(tournament =>
          tournament.rounds && 
          tournament.rounds.some(round => round.ongoing === true)
        );
        setTournaments(ongoingTournaments);
      })
      .catch(error => console.error("Error fetching tournaments:", error));
  }, []);

  const handleSelect = (roundId) => {
    setSelectedTournaments(prev =>
      prev.includes(roundId)
        ? prev.filter(id => id !== roundId)
        : [...prev, roundId]
    );
  };

  const confirmSelection = () => {
    onSelect(selectedTournaments);
  };

  return (
    <div>
      <h1>Live Broadcasts</h1>
      {tournaments.map(tournament => (
        <div key={tournament.tour.id}>
          <h2>{tournament.tour.name}</h2>
          {tournament.rounds.filter(r => r.ongoing).map(round => (
            <div key={round.id}>
              <input
                type="checkbox"
                checked={selectedTournaments.includes(round.id)}
                onChange={() => handleSelect(round.id)}
              />
              <label>{round.name}</label>
            </div>
          ))}
        </div>
      ))}
      <button onClick={confirmSelection}>Confirm</button>
    </div>
  );
};

export default TournamentsList;
```

### Step 4: Create Main App Component

**Create [src/app/evalbars/App.js](file:///c:/Users/2025/Desktop/Code/eval-bar/src/app/evalbars/App.js)**:

```javascript
import React, { useState, useRef, useEffect } from "react";
import { Chess } from "chess.js";
import TournamentsList from "../../components/tournaments-list/TournamentsList";
import EvalBar from "../../components/evalbar/EvalBar";

function App() {
  const [links, setLinks] = useState([]);
  const [availableGames, setAvailableGames] = useState([]);
  const [isBroadcastLoaded, setIsBroadcastLoaded] = useState(false);
  const allGames = useRef("");
  const abortControllers = useRef({});

  const fetchEvaluation = async (fen) => {
    const endpoint = `http://localhost:5000/evaluate?fen=${encodeURIComponent(fen)}`;
    const response = await fetch(endpoint);
    return await response.json();
  };

  const startStreaming = async (tournamentId) => {
    if (abortControllers.current[tournamentId])
      abortControllers.current[tournamentId].abort();
    
    abortControllers.current[tournamentId] = new AbortController();
    
    const streamURL = `https://lichess.org/api/stream/broadcast/round/${tournamentId}.pgn`;
    const response = await fetch(streamURL, {
      signal: abortControllers.current[tournamentId].signal
    });
    
    const reader = response.body.getReader();
    
    const processStream = async () => {
      const { done, value } = await reader.read();
      if (done) return;
      
      allGames.current += new TextDecoder().decode(value);
      updateEvaluations();
      fetchAvailableGames();
      
      setTimeout(processStream, 10);
    };
    
    processStream();
  };

  const fetchAvailableGames = () => {
    const games = allGames.current.split("\n\n\n");
    const gameOptions = games
      .map(game => {
        const whiteMatch = game.match(/\[White "(.*?)"\]/);
        const blackMatch = game.match(/\[Black "(.*?)"\]/);
        return whiteMatch && blackMatch
          ? `${whiteMatch[1]} - ${blackMatch[1]}`
          : null;
      })
      .filter(Boolean);
    
    setAvailableGames(Array.from(new Set(gameOptions)));
  };

  const updateEvaluationsForLink = async (link) => {
    const games = allGames.current.split("\n\n\n");
    const specificGamePgn = games.reverse().find(game => {
      const whiteNameMatch = game.match(/\[White "(.*?)"\]/);
      const blackNameMatch = game.match(/\[Black "(.*?)"\]/);
      return whiteNameMatch && blackNameMatch &&
        `${whiteNameMatch[1]} - ${blackNameMatch[1]}` === 
        `${link.whitePlayer} - ${link.blackPlayer}`;
    });

    if (specificGamePgn) {
      const cleanedPgn = specificGamePgn
        .split("\n")
        .filter(line => !line.startsWith("["))
        .join(" ")
        .replace(/ {.*?}/g, "")
        .trim();

      const chess = new Chess();
      try {
        chess.loadPgn(cleanedPgn);
        const currentFEN = chess.fen();

        if (currentFEN !== link.lastFEN) {
          const evalData = await fetchEvaluation(currentFEN);
          
          setLinks(prevLinks => {
            const updatedLinks = [...prevLinks];
            const idx = updatedLinks.findIndex(l =>
              l.whitePlayer === link.whitePlayer &&
              l.blackPlayer === link.blackPlayer
            );
            
            if (idx !== -1) {
              updatedLinks[idx] = {
                ...link,
                evaluation: evalData.evaluation,
                lastFEN: currentFEN
              };
            }
            
            return updatedLinks;
          });
        }
      } catch (error) {
        console.error("Error loading PGN:", error);
      }
    }
  };

  const updateEvaluations = async () => {
    for (let link of links) {
      await updateEvaluationsForLink(link);
      await new Promise(resolve => setTimeout(resolve, 200));
    }
  };

  const handleTournamentSelection = (tournamentIds) => {
    setIsBroadcastLoaded(true);
    tournamentIds.forEach(tournamentId => startStreaming(tournamentId));
  };

  useEffect(() => {
    if (links.length) {
      const interval = setInterval(() => {
        updateEvaluations();
      }, 2000);
      
      return () => clearInterval(interval);
    }
  }, [links]);

  return (
    <div>
      {!isBroadcastLoaded ? (
        <TournamentsList onSelect={handleTournamentSelection} />
      ) : (
        <div>
          <h2>Available Games</h2>
          {availableGames.map((game, index) => (
            <button key={index} onClick={() => addGame(game)}>
              {game}
            </button>
          ))}
          
          <div>
            {links.map((link, index) => (
              <EvalBar
                key={index}
                evaluation={link.evaluation}
                whitePlayer={link.whitePlayer}
                blackPlayer={link.blackPlayer}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

export default App;
```

### Step 5: Create EvalBar Component

**Create [src/components/evalbar/EvalBar.js](file:///c:/Users/2025/Desktop/Code/eval-bar/src/components/evalbar/EvalBar.js)**:

```javascript
import React from "react";
import "./EvalBar.css";

function EvalBar({ evaluation, whitePlayer, blackPlayer }) {
  const getWhiteBarWidth = () => {
    if (evaluation >= 99) return "100%";
    if (evaluation >= 4) return "90%";
    if (evaluation <= -4) return "10%";
    return `${50 + (evaluation * 7.5)}%`;
  };

  return (
    <div className="eval-container">
      <div className="player-names">
        <span className="white-player">{whitePlayer}</span>
        <span className="black-player">{blackPlayer}</span>
      </div>
      
      <div className="evaluation-display">{evaluation}</div>
      
      <div className="eval-bar-container">
        <div 
          className="white-bar" 
          style={{ width: getWhiteBarWidth() }}
        ></div>
      </div>
    </div>
  );
}

export default EvalBar;
```

**Create [src/components/evalbar/EvalBar.css](file:///c:/Users/2025/Desktop/Code/eval-bar/src/components/evalbar/EvalBar.css)**:

```css
.eval-container {
  background: #000;
  border: 1px solid #fff;
  border-radius: 6px;
  padding: 10px;
  margin: 10px;
  position: relative;
}

.player-names {
  display: flex;
  justify-content: space-between;
  color: white;
  font-weight: bold;
  margin-bottom: 5px;
}

.evaluation-display {
  text-align: center;
  color: white;
  font-size: 20px;
  font-weight: bold;
  margin: 5px 0;
}

.eval-bar-container {
  height: 30px;
  background: #E79D29;
  border-radius: 15px;
  overflow: hidden;
  position: relative;
}

.white-bar {
  height: 100%;
  background: white;
  transition: width 0.3s ease;
}
```

### Step 6: Run the Application

```bash
# Terminal 1 - Start Backend
python chess_api.py

# Terminal 2 - Start Frontend
npm start
```

---

## Deployment

### Frontend Deployment

```bash
# Build production bundle
npm run build

# Deploy to hosting service (Vercel, Netlify, etc.)
# Example: Vercel
vercel deploy --prod
```

### Backend Deployment

**Option 1: Heroku**
```bash
heroku create chess-broadcast-backend
git push heroku main
```

**Option 2: Railway/Render**
- Connect GitHub repository
- Set build command: `pip install -r requirements.txt`
- Set start command: `python chess_api.py`

### Environment Variables

**Frontend (.env)**:
```
REACT_APP_STOCKFISH_API=https://your-backend.com/evaluate
```

**Backend**:
```
FLASK_ENV=production
PORT=5000
```

---

## Advanced Features

### 1. Game Result Detection

The app detects game endings by parsing PGN result tags:

```javascript
const resultMatch = cleanedPgn.match(/(1-0|0-1|1\/2-1\/2)$/);
if (resultMatch) {
  const result = resultMatch[1];
  if (result === "1-0") gameResult = "1-0";
  else if (result === "0-1") gameResult = "0-1";
  else if (result === "1/2-1/2") gameResult = "Draw";
}
```

### 2. Blunder Alert System

Blunders are detected when evaluation swings significantly:

```javascript
const isBlunder = (prevEval, currentEval) => {
  if (prevEval >= -4 && prevEval <= 4) {
    if (Math.abs(currentEval - prevEval) >= 0.6) {
      return true;
    }
  }
  return false;
};
```

When detected:
- Audio alert plays
- Red indicator appears
- Border blinks for 40 seconds

### 3. Custom Styling

Users can customize:
- Evaluation bar colors (white/black)
- Player name colors
- Container background
- Border colors

```javascript
const [customStyles, setCustomStyles] = useState({
  evalContainerBg: "#000000",
  blackBarColor: "#E79D29",
  whiteBarColor: "#ffffff",
  whitePlayerColor: "Transparent",
  blackPlayerColor: "Transparent",
  whitePlayerNameColor: "#FFFFFF",
  blackPlayerNameColor: "#E79D29",
  evalContainerBorderColor: "#FFFFFF"
});
```

### 4. Player Name Formatting

Special handling for common chess players:

```javascript
const formatName = (name) => {
  const cleanedName = name.replace(/[,.;]/g, "").trim();
  const parts = cleanedName.split(" ").filter(part => part.length > 0);
  
  // Special cases
  if (parts.includes("Praggnanandhaa")) return "Pragg";
  if (parts.includes("Nepomniachtchi")) return "Nepo";
  if (parts.includes("Goryachkina")) return "Gorya";
  if (parts.includes("Gukesh")) return "Gukesh";
  
  // Find shortest name part
  return parts.reduce((shortest, part) => 
    part.length < shortest.length ? part : shortest
  );
};
```

---

## Troubleshooting

### Common Issues

**1. CORS Errors**
- Ensure Flask-CORS is installed: `pip install flask-cors`
- Add CORS headers in backend:
  ```python
  CORS(app)
  ```

**2. PGN Parsing Errors**
- Chess.js may fail on invalid PGN
- Wrap in try-catch:
  ```javascript
  try {
    chess.loadPgn(cleanedPgn);
  } catch (error) {
    console.error("Invalid PGN:", error);
  }
  ```

**3. Stream Disconnections**
- Implement reconnection logic:
  ```javascript
  const reconnect = () => {
    setTimeout(() => startStreaming(tournamentId), 5000);
  };
  ```

**4. Memory Leaks**
- Clean up abort controllers:
  ```javascript
  useEffect(() => {
    return () => {
      Object.values(abortControllers.current).forEach(controller => 
        controller.abort()
      );
    };
  }, []);
  ```

---

## Performance Optimization

### 1. Debounce Evaluation Updates

```javascript
const debouncedUpdate = debounce(() => {
  updateEvaluations();
}, 2000);
```

### 2. Memoize Game Parsing

```javascript
const memoizedGames = useMemo(() => {
  return allGames.current.split("\n\n\n");
}, [allGames.current]);
```

### 3. Limit Concurrent Evaluations

```javascript
const updateEvaluations = async () => {
  for (let link of links) {
    await updateEvaluationsForLink(link);
    await new Promise(resolve => setTimeout(resolve, 200)); // Rate limit
  }
};
```

---

## Security Considerations

1. **API Rate Limiting**: Respect Lichess API rate limits
2. **Input Validation**: Validate FEN strings before sending to Stockfish
3. **HTTPS**: Use HTTPS for production deployments
4. **Environment Variables**: Store API endpoints in environment variables

---

## Conclusion

This implementation guide covers all essential aspects of building a chess broadcasting application that:

1. ✅ Fetches live ongoing tournaments from Lichess
2. ✅ Streams live game positions using Server-Sent Events
3. ✅ Evaluates positions with Stockfish
4. ✅ Displays real-time evaluation bars
5. ✅ Detects blunders and game results
6. ✅ Supports multiple simultaneous games

The architecture is scalable, maintainable, and can be extended with additional features like:
- Chess board visualization
- Move history
- Player ratings
- Tournament standings
- Chat integration
- Mobile responsiveness

**Key Technologies**:
- React for UI
- Lichess API for tournament data
- Server-Sent Events for live streaming
- Stockfish for position evaluation
- Chess.js for PGN parsing

This guide should enable another AI instance (or developer) to fully recreate this application with all its core features intact.
